/**
 * RIS::Connections
 * ## Info  * powered by [DB Reisendeninformation](https://db-planet.deutschebahn.com/pages/reisendeninformation/apps/content/willkommen) * member of the [RIS-API](https://db.de/ris-api) family, the building kit for traveller information * for details check out [RIS::Connections](https://api-portal.hub.db.de/db/apis/product/ris-connections) in the DB API Portal  ## Capabilities  Provides a list of connections [Anschlüsse] for an arrival [Ankunft] of a journey [Fahrt], e.g. departures [Abfahrten] of other journeys at the stop place [Haltestelle] of the arrival within a given period.  * connection leaving from other stop places [Haltestellen] of the same group [Umstiegsbereich] (e.g. \'Frankfurt Hoch\' and \'Frankfurt Tief\' within the same station \'Frankfurt Hbf\') for example can be included * connections are classified whether they are based on predefined connections [Plananschlüsse] or based on time information * disposition status (e.g. waiting / not waiting) is included * connection evaluation [Anschlussbewertung] (e.g. safe, critical or impossible) is available for different types of travellers [Personae] * disruptions [Störungen] for connections and stop-place [Haltestelle]  The connection evaluation is based on  * the current information on forecast times and platforms of the arriving journey * the current information on forecast times and platforms for the connecting journeys * transfer times [Umstiegszeiten] within stop place (group) [Haltestelle (Umstiegsbereich)] based on real indoor routing information, differentiating barrier-free routes for travellers with reduced mobility [MER] * transfer times within stop place (group) [Haltestelle (Umstiegsbereich)] from official guidelines [Konzernrichtlinie] in case no indoor routing is available  Please note that the service also provides an information on whether the connection would have been reachable based on scheduled-times or not.  Connecting journeys are suppressed if  * all remaining stops of connecting journey can be reached in the same time or faster with remaining stops of arriving journey and * all remaining stops of connecting journey are preceding stops of the arriving journey  [Restlaufwegprüfung] * preceding stops of arriving journey are a subset of preceding stops of connecting journey [Vorlaufprüfung] * remaining stops of journeys are identical (fastest safe connection will remain) * journey occurs multiple times in list (this may happen due to departures of the same journey at different stop-places [Haltestellen] of a stop place group [Umstiegsbereich]; \'safest\' connection will remain)  Details on the logic can be found within the [RIS-API documentation space](https://ris.gitpages.tech.rz.db.de/risapi/documentation/04_Bausteine/030_RIS_Connections.html).  ## Limitations / Known Issues  * journeys are limited to 22h ahead  ## Getting Started  * visit our [documentation](https://ris-api.gitpages.tech.rz.db.de), learn how to [get started with openapi](https://developer-docs.deutschebahn.com/doku/apis/openapi.html) or how to [get started with asyncapi](https://developer-docs.deutschebahn.com/doku/apis/asyncapi.html) and check out our [coding-examples](https://developer-docs.deutschebahn.com/doku/apis) * bounty hunter, bug finder or just idea creator, we are thirsty to hear from you - get in touch with us by using [DB AnwenderEcho](https://anwenderecho.extranet.deutschebahn.com/ris-api/) or write an [email](mailto:ris-api@deutschebahn.com)  ## Changelog  <details>  ### 1.17.1  #### Added  * added `journeyDescription` and `categoryInternal` to all transport-objects (`TransportPublicDestination`)  ### 1.16.8  #### Changed  * fixed wrong length for `arrivalOrDepartureID`, `departureID` and `arrivalID` from `10` to `12`  </details> 
 *
 * OpenAPI spec version: 1.17.1.6
 * Contact: ris-fachbetrieb@deutschebahn.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Administration } from '../models/Administration';
import { CodeShare } from '../models/CodeShare';
import { ConnectionEvaluationLegacy } from '../models/ConnectionEvaluationLegacy';
import { ConnectionPlatformHint } from '../models/ConnectionPlatformHint';
import { ConnectionSource } from '../models/ConnectionSource';
import { ContractualKnowledge } from '../models/ContractualKnowledge';
import { DispositionStatus } from '../models/DispositionStatus';
import { DisruptionCommunicationEmbeddedLegacy } from '../models/DisruptionCommunicationEmbeddedLegacy';
import { JourneyType } from '../models/JourneyType';
import { MessageAttributeLegacy } from '../models/MessageAttributeLegacy';
import { MessageLegacy } from '../models/MessageLegacy';
import { StopPlaceEmbedded } from '../models/StopPlaceEmbedded';
import { TimeType } from '../models/TimeType';
import { TransportPublicDestination } from '../models/TransportPublicDestination';
import { TransportPublicDestinationPortionWorking } from '../models/TransportPublicDestinationPortionWorking';
import { TransportPublicDestinationVia } from '../models/TransportPublicDestinationVia';
import { HttpFile } from '../http/http';

/**
* Departure information within departure boards [Abfahrtstafeln] with connect info [Anschlussinformation].
*/
export class StopDepartureConnect {
    /**
    * Indicates whether this departure is additional [Zusatzhalt], meaning not be part of the regular schedule.
    */
    'additional': boolean;
    'administration': Administration;
    /**
    * List of journey-attributes [Fahrtmerkmale / Sollmerkmale] for particular stop..
    */
    'attributes'?: Array<MessageAttributeLegacy>;
    /**
    * Indicates whether the departure has been canceled [Haltausfall].
    */
    'canceled': boolean;
    /**
    * List of codeshares [Code-Teilungen mit Flügen verschiedener Fluggesellschaften] for this particular journey at this arrival / departure.
    */
    'codeshares'?: Array<CodeShare>;
    'connectionSource': ConnectionSource;
    /**
    * Connection status [Anschlussbewertung] for different personae based on best known time information.
    */
    'connectionStatusByPersona': Array<ConnectionEvaluationLegacy>;
    /**
    * Connection status [Anschlussbewertung] for different personae based on scheduled times. Useful if you want to know whether the connection was possible based on scheduled information. Take care that additional departures or additional trains have never been possible based on scheduled information.
    */
    'connectionStatusByPersonaScheduled': Array<ConnectionEvaluationLegacy>;
    'continuationBy'?: TransportPublicDestination;
    'contractualKnowledge'?: ContractualKnowledge;
    /**
    * ID of departure [AbfahrtID].
    */
    'departureID': string;
    'dispositionStatus'?: DispositionStatus;
    /**
    * List of disruptions [Stoerungsinformationen] for particular stop.
    */
    'disruptions'?: Array<DisruptionCommunicationEmbeddedLegacy>;
    /**
    * Indicates whether there is at least one disruption in the future of this journey.
    */
    'futureDisruptions': boolean;
    /**
    * ID of journey [FahrtID].
    */
    'journeyID': string;
    'journeyType': JourneyType;
    /**
    * List of available messages to display for this departure.
    */
    'messages'?: Array<MessageLegacy>;
    /**
    * Indicates whether stop is an on demand stop [Bedarfshalt].
    */
    'onDemand': boolean;
    /**
    * Actual platform [Gleis, Bahnsteig, Plattform] the transport departs at.
    */
    'platform': string;
    'platformHint': ConnectionPlatformHint;
    /**
    * Scheduled platform [Gleis, Bahnsteig, Plattform] the transport departs at.
    */
    'platformSchedule'?: string;
    /**
    * List of transports this journey is reliefed by [Entlastungszug].
    */
    'reliefBy'?: Array<TransportPublicDestination>;
    /**
    * List of transports this journey reliefs for [Entlastungszug].
    */
    'reliefFor'?: Array<TransportPublicDestination>;
    /**
    * List of transports this journey is replaced by [Ersatzzug].
    */
    'replacedBy'?: Array<TransportPublicDestination>;
    /**
    * List of transports this journey replaces [Ersatzzug].
    */
    'replacementFor'?: Array<TransportPublicDestination>;
    'station': StopPlaceEmbedded;
    /**
    * Best known time information of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
    */
    'time': Date;
    /**
    * Scheduled time [Abfahrtszeit Soll] of stop as fully qualified date (for instance \'2019-08-19T12:56:14+02:00\' or \'2019-08-19T10:56:14Z\').
    */
    'timeSchedule': Date;
    'timeType': TimeType;
    'transport': TransportPublicDestinationVia;
    /**
    * List of journeys this journey travels with [Vereinigung].
    */
    'travelsWith'?: Array<TransportPublicDestinationPortionWorking>;

    static readonly discriminator: string | undefined = undefined;

    static readonly mapping: {[index: string]: string} | undefined = undefined;

    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [
        {
            "name": "additional",
            "baseName": "additional",
            "type": "boolean",
            "format": ""
        },
        {
            "name": "administration",
            "baseName": "administration",
            "type": "Administration",
            "format": ""
        },
        {
            "name": "attributes",
            "baseName": "attributes",
            "type": "Array<MessageAttributeLegacy>",
            "format": ""
        },
        {
            "name": "canceled",
            "baseName": "canceled",
            "type": "boolean",
            "format": ""
        },
        {
            "name": "codeshares",
            "baseName": "codeshares",
            "type": "Array<CodeShare>",
            "format": ""
        },
        {
            "name": "connectionSource",
            "baseName": "connectionSource",
            "type": "ConnectionSource",
            "format": ""
        },
        {
            "name": "connectionStatusByPersona",
            "baseName": "connectionStatusByPersona",
            "type": "Array<ConnectionEvaluationLegacy>",
            "format": ""
        },
        {
            "name": "connectionStatusByPersonaScheduled",
            "baseName": "connectionStatusByPersonaScheduled",
            "type": "Array<ConnectionEvaluationLegacy>",
            "format": ""
        },
        {
            "name": "continuationBy",
            "baseName": "continuationBy",
            "type": "TransportPublicDestination",
            "format": ""
        },
        {
            "name": "contractualKnowledge",
            "baseName": "contractualKnowledge",
            "type": "ContractualKnowledge",
            "format": ""
        },
        {
            "name": "departureID",
            "baseName": "departureID",
            "type": "string",
            "format": ""
        },
        {
            "name": "dispositionStatus",
            "baseName": "dispositionStatus",
            "type": "DispositionStatus",
            "format": ""
        },
        {
            "name": "disruptions",
            "baseName": "disruptions",
            "type": "Array<DisruptionCommunicationEmbeddedLegacy>",
            "format": ""
        },
        {
            "name": "futureDisruptions",
            "baseName": "futureDisruptions",
            "type": "boolean",
            "format": ""
        },
        {
            "name": "journeyID",
            "baseName": "journeyID",
            "type": "string",
            "format": ""
        },
        {
            "name": "journeyType",
            "baseName": "journeyType",
            "type": "JourneyType",
            "format": ""
        },
        {
            "name": "messages",
            "baseName": "messages",
            "type": "Array<MessageLegacy>",
            "format": ""
        },
        {
            "name": "onDemand",
            "baseName": "onDemand",
            "type": "boolean",
            "format": ""
        },
        {
            "name": "platform",
            "baseName": "platform",
            "type": "string",
            "format": ""
        },
        {
            "name": "platformHint",
            "baseName": "platformHint",
            "type": "ConnectionPlatformHint",
            "format": ""
        },
        {
            "name": "platformSchedule",
            "baseName": "platformSchedule",
            "type": "string",
            "format": ""
        },
        {
            "name": "reliefBy",
            "baseName": "reliefBy",
            "type": "Array<TransportPublicDestination>",
            "format": ""
        },
        {
            "name": "reliefFor",
            "baseName": "reliefFor",
            "type": "Array<TransportPublicDestination>",
            "format": ""
        },
        {
            "name": "replacedBy",
            "baseName": "replacedBy",
            "type": "Array<TransportPublicDestination>",
            "format": ""
        },
        {
            "name": "replacementFor",
            "baseName": "replacementFor",
            "type": "Array<TransportPublicDestination>",
            "format": ""
        },
        {
            "name": "station",
            "baseName": "station",
            "type": "StopPlaceEmbedded",
            "format": ""
        },
        {
            "name": "time",
            "baseName": "time",
            "type": "Date",
            "format": "date-time"
        },
        {
            "name": "timeSchedule",
            "baseName": "timeSchedule",
            "type": "Date",
            "format": "date-time"
        },
        {
            "name": "timeType",
            "baseName": "timeType",
            "type": "TimeType",
            "format": ""
        },
        {
            "name": "transport",
            "baseName": "transport",
            "type": "TransportPublicDestinationVia",
            "format": ""
        },
        {
            "name": "travelsWith",
            "baseName": "travelsWith",
            "type": "Array<TransportPublicDestinationPortionWorking>",
            "format": ""
        }    ];

    static getAttributeTypeMap() {
        return StopDepartureConnect.attributeTypeMap;
    }

    public constructor() {
    }
}


